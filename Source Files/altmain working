#include <iostream>
#include <vector>
#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include "shaderClass.h"
#include <EBO.h>
#include <VBO.h>
#include <VAO.h>

// settings
const unsigned int SCR_WIDTH = 800;
const unsigned int SCR_HEIGHT = 600;

// Camera variables
glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 5.0f);
glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);
glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);
float yaw = -90.0f;
float pitch = 0.0f;
float lastX = SCR_WIDTH / 2.0f;
float lastY = SCR_HEIGHT / 2.0f;
bool firstMouse = true;
float fov = 45.0f;

// Timing
float deltaTime = 0.0f;
float lastFrame = 0.0f;

// Bezier curve class with width
class BezierCurve {
public:
    std::vector<glm::vec3> controlPoints;
    std::vector<glm::vec3> curvePoints;
    std::vector<float> arcLengthTable;
    std::vector<float> tValues;
    float totalLength;
    float width;

    BezierCurve(const std::vector<glm::vec3>& points, float curveWidth = 0.2f)
        : controlPoints(points), width(curveWidth) {
        GenerateCurve(100);
        BuildArcLengthTable();
    }

    glm::vec3 Evaluate(float t) {
        if (controlPoints.empty()) return glm::vec3(0.0f);

        std::vector<glm::vec3> points = controlPoints;
        while (points.size() > 1) {
            std::vector<glm::vec3> newPoints;
            for (size_t i = 0; i < points.size() - 1; i++) {
                newPoints.push_back((1 - t) * points[i] + t * points[i + 1]);
            }
            points = newPoints;
        }
        return points[0];
    }

    void GenerateCurve(int segments) {
        curvePoints.clear();
        for (int i = 0; i <= segments; i++) {
            float t = static_cast<float>(i) / segments;
            curvePoints.push_back(Evaluate(t));
        }
    }

    void BuildArcLengthTable() {
        if (curvePoints.empty()) return;

        arcLengthTable.clear();
        tValues.clear();
        totalLength = 0.0f;

        arcLengthTable.push_back(0.0f);
        tValues.push_back(0.0f);

        for (size_t i = 1; i < curvePoints.size(); i++) {
            float segmentLength = glm::distance(curvePoints[i], curvePoints[i - 1]);
            totalLength += segmentLength;
            arcLengthTable.push_back(totalLength);
            tValues.push_back(static_cast<float>(i) / (curvePoints.size() - 1));
        }
    }

    float GetTForArcLength(float s) {
        if (s <= 0) return 0.0f;
        if (s >= totalLength) return 1.0f;

        size_t i = 1;
        while (i < arcLengthTable.size() && arcLengthTable[i] < s) {
            i++;
        }

        float s0 = arcLengthTable[i - 1];
        float s1 = arcLengthTable[i];
        float t0 = tValues[i - 1];
        float t1 = tValues[i];

        float alpha = (s - s0) / (s1 - s0);
        return t0 + alpha * (t1 - t0);
    }

    // Generate vertices for a wide ribbon along the curve
    void GenerateRibbonVertices(std::vector<GLfloat>& vertices, std::vector<GLuint>& indices) {
        if (curvePoints.size() < 2) return;

        vertices.clear();
        indices.clear();

        // Calculate normals (binormals) for each point
        std::vector<glm::vec3> binormals;
        for (size_t i = 0; i < curvePoints.size(); i++) {
            glm::vec3 tangent;
            if (i == 0) {
                tangent = glm::normalize(curvePoints[i + 1] - curvePoints[i]);
            }
            else if (i == curvePoints.size() - 1) {
                tangent = glm::normalize(curvePoints[i] - curvePoints[i - 1]);
            }
            else {
                tangent = glm::normalize(curvePoints[i + 1] - curvePoints[i - 1]);
            }

            glm::vec3 up(0.0f, 1.0f, 0.0f);
            glm::vec3 binormal = glm::normalize(glm::cross(tangent, up));

            // If the curve is vertical, use a different up vector
            if (glm::length(binormal) < 0.001f) {
                up = glm::vec3(1.0f, 0.0f, 0.0f);
                binormal = glm::normalize(glm::cross(tangent, up));
            }

            binormals.push_back(binormal);
        }

        // Generate vertices for both sides of the ribbon
        for (size_t i = 0; i < curvePoints.size(); i++) {
            glm::vec3 point = curvePoints[i];
            glm::vec3 binormal = binormals[i];

            // Left side vertex
            glm::vec3 left = point - binormal * width;
            vertices.push_back(left.x);
            vertices.push_back(left.y);
            vertices.push_back(left.z);

            // Right side vertex
            glm::vec3 right = point + binormal * width;
            vertices.push_back(right.x);
            vertices.push_back(right.y);
            vertices.push_back(right.z);
        }

        // Generate indices for triangles
        for (size_t i = 0; i < curvePoints.size() - 1; i++) {
            // First triangle
            indices.push_back(i * 2);
            indices.push_back(i * 2 + 1);
            indices.push_back(i * 2 + 2);

            // Second triangle
            indices.push_back(i * 2 + 1);
            indices.push_back(i * 2 + 3);
            indices.push_back(i * 2 + 2);
        }
    }
};

class MultiBezierPath {
public:
    std::vector<BezierCurve> curves;
    std::vector<float> curveLengths;
    float totalLength;

    MultiBezierPath(const std::vector<std::vector<glm::vec3>>& curveControlPoints, float width = 0.2f) {
        for (const auto& points : curveControlPoints) {
            curves.emplace_back(points, width);
        }

        totalLength = 0.0f;
        for (auto& curve : curves) {
            curveLengths.push_back(curve.totalLength);
            totalLength += curve.totalLength;
        }
    }

    glm::vec3 Evaluate(float s) {
        if (s <= 0) return curves.front().Evaluate(0);
        if (s >= totalLength) return curves.back().Evaluate(1);

        float accumulatedLength = 0.0f;
        size_t curveIndex = 0;
        for (; curveIndex < curves.size(); curveIndex++) {
            if (s <= accumulatedLength + curveLengths[curveIndex]) {
                break;
            }
            accumulatedLength += curveLengths[curveIndex];
        }

        float curveDistance = s - accumulatedLength;
        return curves[curveIndex].Evaluate(curves[curveIndex].GetTForArcLength(curveDistance));
    }

    void GenerateAllRibbonVertices(std::vector<GLfloat>& vertices, std::vector<GLuint>& indices) {
        vertices.clear();
        indices.clear();

        GLuint indexOffset = 0;
        for (auto& curve : curves) {
            std::vector<GLfloat> curveVertices;
            std::vector<GLuint> curveIndices;

            curve.GenerateRibbonVertices(curveVertices, curveIndices);

            // Offset indices for the current curve
            for (auto& index : curveIndices) {
                indices.push_back(index + indexOffset);
            }

            // Add vertices
            vertices.insert(vertices.end(), curveVertices.begin(), curveVertices.end());

            // Update index offset for next curve
            indexOffset += curveVertices.size() / 3;
        }
    }

    std::vector<glm::vec3> GetAllControlPoints() {
        std::vector<glm::vec3> allPoints;
        for (auto& curve : curves) {
            allPoints.insert(allPoints.end(), curve.controlPoints.begin(), curve.controlPoints.end());
        }
        return allPoints;
    }
};

// Camera control callbacks
void mouse_callback(GLFWwindow* window, double xpos, double ypos) {
    if (firstMouse) {
        lastX = xpos;
        lastY = ypos;
        firstMouse = false;
    }

    float xoffset = xpos - lastX;
    float yoffset = lastY - ypos;
    lastX = xpos;
    lastY = ypos;

    float sensitivity = 0.1f;
    xoffset *= sensitivity;
    yoffset *= sensitivity;

    yaw += xoffset;
    pitch += yoffset;

    if (pitch > 89.0f)
        pitch = 89.0f;
    if (pitch < -89.0f)
        pitch = -89.0f;

    glm::vec3 front;
    front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
    front.y = sin(glm::radians(pitch));
    front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
    cameraFront = glm::normalize(front);
}

void scroll_callback(GLFWwindow* window, double xoffset, double yoffset) {
    fov -= (float)yoffset;
    if (fov < 1.0f)
        fov = 1.0f;
    if (fov > 45.0f)
        fov = 45.0f;
}

void processInput(GLFWwindow* window) {
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);

    float cameraSpeed = 2.5f * deltaTime;
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
        cameraPos += cameraSpeed * cameraFront;
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
        cameraPos -= cameraSpeed * cameraFront;
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
        cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
        cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
}

int main() {
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "3D Ribbon Bezier Curves", NULL, NULL);
    if (window == NULL) {
        std::cout << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetCursorPosCallback(window, mouse_callback);
    glfwSetScrollCallback(window, scroll_callback);
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

    gladLoadGL();
    glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT);
    glEnable(GL_DEPTH_TEST);

    // Create shaders
    Shader ribbonShader(RESOURCE_PATH "shaders/ribbon.vert", RESOURCE_PATH "shaders/ribbon.frag");
    Shader objectShader(RESOURCE_PATH "shaders/object.vert", RESOURCE_PATH "shaders/object.frag");
    Shader controlShader(RESOURCE_PATH "shaders/control.vert", RESOURCE_PATH "shaders/control.frag");

    // Define multiple connected 3D Bezier curves with width
    float ribbonWidth = 0.3f;
    std::vector<std::vector<glm::vec3>> curvesControlPoints = {
        // First curve
        {
            glm::vec3(-1.0f, -1.0f, 0.0f),
            glm::vec3(-0.5f, 1.0f, 0.5f),
            glm::vec3(0.5f, -1.0f, -0.5f),
            glm::vec3(1.0f, 1.0f, 0.0f)
        },
        // Second curve
        {
            glm::vec3(1.0f, 1.0f, 0.0f),
            glm::vec3(1.5f, -0.5f, 1.0f),
            glm::vec3(0.5f, -1.5f, -1.0f),
            glm::vec3(-1.0f, 0.5f, 0.5f)
        },
        // Third curve
        {
            glm::vec3(-1.0f, 0.5f, 0.5f),
            glm::vec3(-1.5f, 1.5f, -0.5f),
            glm::vec3(-0.5f, -0.5f, 1.0f),
            glm::vec3(0.0f, 0.0f, -1.0f)
        }
    };

    MultiBezierPath path(curvesControlPoints, ribbonWidth);

    // Generate ribbon vertices
    std::vector<GLfloat> ribbonVertices;
    std::vector<GLuint> ribbonIndices;
    path.GenerateAllRibbonVertices(ribbonVertices, ribbonIndices);

    // VAO/VBO for the ribbon
    VAO ribbonVAO;
    ribbonVAO.Bind();
    VBO ribbonVBO(&ribbonVertices[0], ribbonVertices.size() * sizeof(GLfloat));
    EBO ribbonEBO(&ribbonIndices[0], ribbonIndices.size() * sizeof(GLuint));
    ribbonVAO.LinkVBO(ribbonVBO, 0);
    ribbonVAO.Unbind();
    ribbonVBO.Unbind();
    ribbonEBO.Unbind();

    // Object to move along the curve (a pyramid)
    GLfloat objectVertices[] = {
        // Base
        -0.1f, -0.1f, -0.1f,
         0.1f, -0.1f, -0.1f,
         0.1f, -0.1f,  0.1f,
        -0.1f, -0.1f,  0.1f,
        // Apex
         0.0f,  0.2f,  0.0f
    };
    GLuint objectIndices[] = {
        // Base
        0, 1, 2,
        0, 2, 3,
        // Sides
        0, 1, 4,
        1, 2, 4,
        2, 3, 4,
        3, 0, 4
    };

    // VAO/VBO for the moving object
    VAO objectVAO;
    objectVAO.Bind();
    VBO objectVBO(objectVertices, sizeof(objectVertices));
    EBO objectEBO(objectIndices, sizeof(objectIndices));
    objectVAO.LinkVBO(objectVBO, 0);
    objectVAO.Unbind();
    objectVBO.Unbind();
    objectEBO.Unbind();

    // Control point visualization
    std::vector<GLfloat> controlPointVertices;
    auto allControlPoints = path.GetAllControlPoints();
    for (const auto& point : allControlPoints) {
        controlPointVertices.push_back(point.x);
        controlPointVertices.push_back(point.y);
        controlPointVertices.push_back(point.z);
    }
    VAO controlPointsVAO;
    controlPointsVAO.Bind();
    VBO controlPointsVBO(&controlPointVertices[0], controlPointVertices.size() * sizeof(GLfloat));
    controlPointsVAO.LinkVBO(controlPointsVBO, 0);
    controlPointsVAO.Unbind();
    controlPointsVBO.Unbind();

    // Animation variables
    float speed = 0.5f;
    float currentDistance = 0.0f;

    while (!glfwWindowShouldClose(window)) {
        // Calculate delta time
        float currentFrame = glfwGetTime();
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;

        // Input
        processInput(window);

        // Update position along path
        currentDistance += speed * deltaTime;
        if (currentDistance > path.totalLength) {
            currentDistance -= path.totalLength;
        }

        // Get current and next positions for orientation
        glm::vec3 objectPosition = path.Evaluate(currentDistance);
        glm::vec3 nextPosition = path.Evaluate(currentDistance + 0.01f);
        glm::vec3 tangent = glm::normalize(nextPosition - objectPosition);

        // Calculate rotation to align with tangent
        glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f);
        glm::vec3 right = glm::normalize(glm::cross(up, tangent));
        up = glm::normalize(glm::cross(tangent, right));

        // Create model matrix for the object
        glm::mat4 model = glm::mat4(1.0f);
        model = glm::translate(model, objectPosition);

        // Create rotation matrix to align with tangent
        glm::mat4 rotation;
        rotation[0] = glm::vec4(right, 0.0f);
        rotation[1] = glm::vec4(up, 0.0f);
        rotation[2] = glm::vec4(tangent, 0.0f);
        rotation[3] = glm::vec4(0.0f, 0.0f, 0.0f, 1.0f);

        model = model * rotation;

        // View and projection matrices
        glm::mat4 view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
        glm::mat4 projection = glm::perspective(glm::radians(fov), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);

        // Clear screen
        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        // Draw the ribbon
        ribbonShader.Activate();
        ribbonShader.setMat4("view", view);
        ribbonShader.setMat4("projection", projection);
        ribbonVAO.Bind();
        glDrawElements(GL_TRIANGLES, ribbonIndices.size(), GL_UNSIGNED_INT, 0);
        ribbonVAO.Unbind();

        // Draw control points
        controlShader.Activate();
        controlShader.setMat4("view", view);
        controlShader.setMat4("projection", projection);
        glPointSize(8.0f);
        controlPointsVAO.Bind();
        glDrawArrays(GL_POINTS, 0, allControlPoints.size());
        controlPointsVAO.Unbind();

        // Draw the moving object
        objectShader.Activate();
        objectShader.setMat4("model", model);
        objectShader.setMat4("view", view);
        objectShader.setMat4("projection", projection);
        objectVAO.Bind();
        glDrawElements(GL_TRIANGLES, sizeof(objectIndices) / sizeof(GLuint), GL_UNSIGNED_INT, 0);
        objectVAO.Unbind();

        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    // Cleanup
    ribbonVAO.Delete();
    ribbonVBO.Delete();
    ribbonEBO.Delete();
    objectVAO.Delete();
    objectVBO.Delete();
    objectEBO.Delete();
    controlPointsVAO.Delete();
    controlPointsVBO.Delete();

    glfwDestroyWindow(window);
    glfwTerminate();
    return 0;
}